from math import inf
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap

import dijkstra_v3 


def compressed_matrix(original_matrix, reduce_scale):
    """
    Returns a compressed matrix of size n * n from a original size

    Exceptions:
    Size of original matrix is not multiples of reduction scale, and this makes reduction number not integer.
    """
    if len(original_matrix)%reduce_scale == 0:
        
        scl = reduce_scale
        l = len(original_matrix)
        n = l//scl# dimensions of compressed matrix
        compressed_matrix = [[0 for _ in range(n)] for _ in range(n)] # initialise the compressed matrix
        
        # sum up n*n blocks
        for i in range(l):
            
            for j in range(l):
                
                compressed_matrix[i//n][j//n] += original_matrix[i][j]
            
        # get the average value for each nodes
        for i in range(n):
            
            for j in range(n):
                
                compressed_matrix[i][j] /= (scl * scl)
                
    else:
        print("Error: either number of rows or columns is not multiples of reduction scale selected, please re-select proper scale. ")
    
    return compressed_matrix



def weighted_matrix(matrix):
    """
    Returns a matrix with a weighted distance, assume direction only go to the right and downward and diagonal downward right.
    with the distance to be the value of started point from orignal matrix

    Exceptions:
    Index out of range, Be careful with last row and last column that some directions are not existed.
    """
    
    l = len(matrix)
    num_v = l * l # number of vertices in matrix
    weighted_matrix = [[0 for _ in range(num_v)] for _ in range(num_v)] # initialise the weighted matrix
    
    for i in range(l):
        if i != l-1:
            for j in range(l):
                if j != l-1:
                    weighted_matrix[i*l+j][i*l+(j+1)] = weighted_matrix[i*l+(j+1)][i*l+j] =matrix[i][j] #direction to right
                    weighted_matrix[i*l+j][(i+1)*l+j] = weighted_matrix[(i+1)*l+j][i*l+j] =matrix[i][j] #direction to downward
                    weighted_matrix[i*l+j][(i+1)*l+(j+1)] = weighted_matrix[(i+1)*l+(j+1)][i*l+j] =matrix[i][j] #diagonal direction
                else:
                    weighted_matrix[i*l+j][(i+1)*l+j] = weighted_matrix[(i+1)*l+j][i*l+j] =matrix[i][j]#direction to downward
        else:
            for j in range(l-1):
             weighted_matrix[i*l+j][i*l+(j+1)] = weighted_matrix[i*l+(j+1)][i*l+j] =matrix[i][j] #direction to right
                

    return weighted_matrix



def draw_heatmap(matrix, max_risk_value):
    
    """
    Returns only a graph of heatmap 
    """
    
    N = max_risk_value 
    cmap = LinearSegmentedColormap.from_list("custom", ["green", "yellow", "red"], N)
    plt.figure(figsize=(10, 8))  # Set the figure size for better readability
    sns.heatmap(matrix, annot=False, cmap=cmap, vmin=1, vmax=N)

    plt.title('Danger Map Heatmap')
    plt.xlabel('Column Index')
    plt.ylabel('Row Index')
    plt.show()
    
    
    
def overall_visualisation(matrix, max_risk_value, list_vertices):
    
    """
    Returns a graph of heatmap with a path line on it.
    """
    
    N = max_risk_value 
    cmap = LinearSegmentedColormap.from_list("custom", ["green", "yellow", "red"], N)
    plt.figure(figsize=(10, 8))  # Set the figure size for better readability
    sns.heatmap(matrix, annot=False, cmap=cmap, vmin=1, vmax=N)

    plt.title('Danger Map Heatmap')
    plt.xlabel('Column Index')
    plt.ylabel('Row Index')
    
    # Plotting the path on the heatmap
    # Unzipping the list of vertices to get separate lists of rows and columns
    rows = [list_vertices[i][0] for i in range(len(list_vertices))]
    cols = [list_vertices[i][1] for i in range(len(list_vertices))]
    plt.plot(cols, rows, color='blue', marker='o', linestyle='-', linewidth=2, markersize=5, label='Path')
    
    plt.legend()
    plt.grid(False) # Turn off the grid to not overlap with the heatmap

    plt.show()



def path2vertex(path, compressed_matrix):
    
    """
    Returns a list of corresponding vertices from path generated by Dijkstra
    """
    
    l = len(compressed_matrix)
    n = len(path)
    list_vertices = []
    
    for i in range(n):
        row = path[i]//l
        column = path[i]%l
        list_vertices.append([row,column])
    
    return list_vertices



def expanded_matrix(list_vertices,original_matrix, reduce_scale, limit):
    
    """
    Returns a list of expanded vertices, which are from the original matrix, can be directly used for visualisation.
    """
    
    expanded_list_vertices = []
    scl = reduce_scale
    
    for i in range(len(list_vertices)-1):
        
        cell_matrix = [[0 for _ in range(scl)] for _ in range(scl)] # initialise the compressed matrix
        
        start_vertex = list_vertices[i]
        end_vertex = list_vertices[i+1]
        
        r = 0
        
        for row in range(start_vertex[0],start_vertex[0]+scl):
            
            c = 0
            for col in range(start_vertex[1],start_vertex[1]+scl):
                
               cell_matrix[r][c] = original_matrix[row][col]
               c += 1
            r+= 1
        
        if start_vertex[0] == end_vertex[0]: # horizontal moving
            end_point = scl-1
        elif start_vertex[1] == end_vertex[1]: # vertical moving
            end_point = scl * (scl-1)       
        else: # diagonal moving
            end_point = scl * scl -1
            
        weighted_cell_matrix = weighted_matrix(cell_matrix)
        optimal_path = dijkstra_v3.find_shortest_path(weighted_cell_matrix, limit, 0, end_point)
        new_list_vertices = path2vertex(optimal_path, cell_matrix)
        
        for j in range(len(new_list_vertices)):
            
            new_list_vertices[j][0] = new_list_vertices[j][0] + start_vertex[0]*scl
            new_list_vertices[j][1] = new_list_vertices[j][1] + start_vertex[1]*scl
            
            expanded_list_vertices.append(new_list_vertices[j])
     
    return expanded_list_vertices